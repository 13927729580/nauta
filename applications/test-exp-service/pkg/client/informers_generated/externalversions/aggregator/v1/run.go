/*
INTEL CONFIDENTIAL
Copyright (c) 2018 Intel Corporation

The source code contained or described herein and all documents related to
the source code ("Material") are owned by Intel Corporation or its suppliers
or licensors. Title to the Material remains with Intel Corporation or its
suppliers and licensors. The Material contains trade secrets and proprietary
and confidential information of Intel or its suppliers and licensors. The
Material is protected by worldwide copyright and trade secret laws and treaty
provisions. No part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in any way
without Intel's prior express written permission.
No license under any patent, copyright, trade secret or other intellectual
property right is granted to or conferred upon you by disclosure or delivery
of the Materials, either expressly, by implication, inducement, estoppel or
otherwise. Any license under such intellectual property rights must be express
and approved by Intel in writing.
*/
// This file was automatically generated by informer-gen

package v1

import (
	aggregator_v1 "github.com/nervanasystems/carbon/applications/test-exp-service/pkg/apis/aggregator/v1"
	clientset "github.com/nervanasystems/carbon/applications/test-exp-service/pkg/client/clientset_generated/clientset"
	internalinterfaces "github.com/nervanasystems/carbon/applications/test-exp-service/pkg/client/informers_generated/externalversions/internalinterfaces"
	v1 "github.com/nervanasystems/carbon/applications/test-exp-service/pkg/client/listers_generated/aggregator/v1"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	watch "k8s.io/apimachinery/pkg/watch"
	cache "k8s.io/client-go/tools/cache"
	time "time"
)

// RunInformer provides access to a shared informer and lister for
// Runs.
type RunInformer interface {
	Informer() cache.SharedIndexInformer
	Lister() v1.RunLister
}

type runInformer struct {
	factory          internalinterfaces.SharedInformerFactory
	tweakListOptions internalinterfaces.TweakListOptionsFunc
	namespace        string
}

// NewRunInformer constructs a new informer for Run type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewRunInformer(client clientset.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
	return NewFilteredRunInformer(client, namespace, resyncPeriod, indexers, nil)
}

// NewFilteredRunInformer constructs a new informer for Run type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredRunInformer(client clientset.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
	return cache.NewSharedIndexInformer(
		&cache.ListWatch{
			ListFunc: func(options meta_v1.ListOptions) (runtime.Object, error) {
				if tweakListOptions != nil {
					tweakListOptions(&options)
				}
				return client.AggregatorV1().Runs(namespace).List(options)
			},
			WatchFunc: func(options meta_v1.ListOptions) (watch.Interface, error) {
				if tweakListOptions != nil {
					tweakListOptions(&options)
				}
				return client.AggregatorV1().Runs(namespace).Watch(options)
			},
		},
		&aggregator_v1.Run{},
		resyncPeriod,
		indexers,
	)
}

func (f *runInformer) defaultInformer(client clientset.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
	return NewFilteredRunInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}

func (f *runInformer) Informer() cache.SharedIndexInformer {
	return f.factory.InformerFor(&aggregator_v1.Run{}, f.defaultInformer)
}

func (f *runInformer) Lister() v1.RunLister {
	return v1.NewRunLister(f.Informer().GetIndexer())
}
